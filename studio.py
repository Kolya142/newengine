import customtkinter as ctk
import os
import subprocess
import threading
import sys
import platform
import time
import shutil
import urllib.request
import zipfile
import io
import re
from tkinter import messagebox, ttk
from pathlib import Path
from typing import List, Optional, Dict

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
class Config:
    APP_NAME = "NewEngine Studio"
    VERSION = "0.7.1" 
    THEME = "Dark"
    ACCENT_COLOR = "blue"
    
    ROOT_DIR = Path(os.getcwd())
    BIN_DIR = ROOT_DIR / "bin"
    OBJ_DIR = BIN_DIR / "obj"
    INCLUDE_DIR = ROOT_DIR / "include"
    ASSETS_DIR = ROOT_DIR / "assets"
    GAME_DIR = ROOT_DIR / "game"
    ENGINE_DIR = ROOT_DIR / "engine"
    
    COMPILER = "gcc"
    OUTPUT_NAME = "game"
    if platform.system() == "Windows":
        OUTPUT_NAME += ".exe"

    URL_STUDIO_RAW = "https://raw.githubusercontent.com/crimbrodev/newengineSTUDIO/main/studio.py"
    URL_ENGINE_ZIP = "https://github.com/Kolya142/newengine/archive/refs/heads/main.zip"

# --- –õ–û–ì–ò–ö–ê –ö–û–ù–í–ï–†–¢–ê–¶–ò–ò –ê–°–°–ï–¢–û–í ---
class AssetConverter:
    @staticmethod
    def convert_obj_to_h(obj_path: Path) -> str:
        name = obj_path.stem.lower().replace(" ", "_")
        vertices, faces = [], []
        try:
            with open(obj_path, 'r') as f:
                for line in f:
                    if line.startswith('v '):
                        p = line.split()
                        vertices.append(f"    {{{p[1]}, {p[2]}, {p[3]}}}")
                    elif line.startswith('f '):
                        p = line.split()
                        idx = [str(int(part.split('/')[0]) - 1) for part in p[1:]]
                        if len(idx) == 3: faces.append(f"    {{{idx[0]}, {idx[1]}, {idx[2]}}}")
                        elif len(idx) == 4:
                            faces.append(f"    {{{idx[0]}, {idx[1]}, {idx[2]}}}")
                            faces.append(f"    {{{idx[0]}, {idx[2]}, {idx[3]}}}")
            content = f"#pragma once\n\n// Generated by NewEngine Studio\n\n"
            content += f"static const NE_Vertex {name}_v[] = {{\n" + ",\n".join(vertices) + "\n};\n\n"
            content += f"static const NE_Color {name}_c[] = {{\n" + ",\n".join(["    {1.0, 1.0, 1.0, 1.0}"] * len(vertices)) + "\n};\n\n"
            content += f"static const NE_Face {name}_f[] = {{\n" + ",\n".join(faces) + "\n};\n\n"
            content += f"static const NE_Model {name}_model = {{\n    {name}_v,\n    {name}_c,\n    {name}_f,\n    {len(faces)}\n}};\n"
            return content
        except Exception as e: return f"ERROR: {str(e)}"

# --- –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´ ---
class SystemHealth:
    @staticmethod
    def check_gcc() -> tuple[bool, str]:
        try:
            res = subprocess.run([Config.COMPILER, "--version"], capture_output=True, text=True)
            return (True, res.stdout.split('\n')[0]) if res.returncode == 0 else (False, "GCC Error")
        except FileNotFoundError: return False, "GCC –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ PATH."

    @staticmethod
    def check_folders() -> List[tuple[str, bool]]:
        return [("engine/", Config.ENGINE_DIR.exists()), ("game/", Config.GAME_DIR.exists()), 
                ("include/", Config.INCLUDE_DIR.exists()), ("bin/", Config.BIN_DIR.exists())]

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –®–ê–ë–õ–û–ù–ê–ú–ò ---
class TemplateManager:
    TEMPLATES = {
        "Minimal": {
            "code": """#include <neweng/engine.h>
int main() {
    NScreen_init(1280, 720, 90., "New Project");
    while (NScreen_IsNtClosed()) {
        NScreen_BeginFrame();
        NScreen_DrawTriangle((NE_Vec3){0,1,2}, (NE_Vec3){-1,-1,2}, (NE_Vec3){1,-1,2}, NE_GREEN);
        NScreen_EndFrame();
    }
    return 0;
}"""
        }
    }
    @staticmethod
    def apply_template(name: str):
        if name in TemplateManager.TEMPLATES:
            Config.GAME_DIR.mkdir(exist_ok=True)
            main_file = Config.GAME_DIR / "main.c"
            if main_file.exists(): shutil.copy(main_file, str(main_file) + ".bak")
            main_file.write_text(TemplateManager.TEMPLATES[name]["code"], encoding="utf-8")
            return True
        return False

# --- –õ–û–ì–ò–ö–ê –û–ë–ù–û–í–õ–ï–ù–ò–Ø ---
class Updater:
    def __init__(self, log_callback): self.log = log_callback
    def update_studio(self):
        self.log("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç—É–¥–∏–∏...\n", "info")
        try:
            with urllib.request.urlopen(Config.URL_STUDIO_RAW) as response:
                if response.status == 200:
                    with open("studio.py.new", "wb") as f: f.write(response.read())
                    os.replace("studio.py.new", "studio.py")
                    self.log("–£–°–ü–ï–®–ù–û! –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É.\n", "success")
        except Exception as e: self.log(f"–û—à–∏–±–∫–∞: {e}\n", "error")

    def update_engine(self):
        self.log("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–∫–∞...\n", "info")
        try:
            with urllib.request.urlopen(Config.URL_ENGINE_ZIP) as response:
                if response.status == 200:
                    zip_data = response.read()
                    with zipfile.ZipFile(io.BytesIO(zip_data)) as z:
                        root = z.namelist()[0].split('/')[0]
                        for folder in ["engine", "include"]:
                            prefix = f"{root}/{folder}/"
                            for file in z.namelist():
                                if file.startswith(prefix) and not file.endswith('/'):
                                    rel = file[len(f"{root}/"):]
                                    dest = Config.ROOT_DIR / rel
                                    dest.parent.mkdir(parents=True, exist_ok=True)
                                    with open(dest, "wb") as f: f.write(z.read(file))
                    self.log("–î–≤–∏–∂–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω!\n", "success")
        except Exception as e: self.log(f"–û—à–∏–±–∫–∞: {e}\n", "error")

# --- –°–õ–ï–ñ–ï–ù–ò–ï –ó–ê –§–ê–ô–õ–ê–ú–ò (Hot Reload) ---
class FileWatcher:
    def __init__(self, build_callback):
        self.build_callback = build_callback
        self.watching = False
        self.file_times: Dict[str, float] = {}

    def start(self):
        self.watching = True
        self._update_times()
        threading.Thread(target=self._watch_loop, daemon=True).start()

    def _update_times(self):
        for d in [Config.ENGINE_DIR, Config.GAME_DIR]:
            if d.exists():
                for f in d.rglob("*.c"): self.file_times[str(f)] = os.path.getmtime(f)

    def _watch_loop(self):
        while self.watching:
            time.sleep(1.0)
            changed = False
            for d in [Config.ENGINE_DIR, Config.GAME_DIR]:
                if d.exists():
                    for f in d.rglob("*.c"):
                        m = os.path.getmtime(f)
                        if str(f) not in self.file_times or m > self.file_times[str(f)]:
                            self.file_times[str(f)] = m
                            changed = True
            if changed: self.build_callback()

# --- –°–ò–°–¢–ï–ú–ê –°–ë–û–†–ö–ò (Profiles + Issues) ---
class BuildSystem:
    def __init__(self, app_instance):
        self.app_instance = app_instance
        self.console_log = app_instance.log_to_console
        self.game_process: Optional[subprocess.Popen] = None
        self.is_building = False
        self.err_pattern = re.compile(r"^(.*):(\d+):(\d+): (error|warning|note): (.*)$")

    def build(self, profile="Debug", run_after=False):
        if self.is_building: return
        threading.Thread(target=self._build_task, args=(profile, run_after), daemon=True).start()

    def _build_task(self, profile, run_after):
        self.is_building = True
        self.app_instance.set_ui_busy(True)
        self.app_instance.clear_console()
        self.app_instance.clear_issues()
        
        if run_after and self.game_process and self.game_process.poll() is None:
            try: self.game_process.terminate(); self.game_process.wait(timeout=1)
            except: pass

        self.console_log(f"--- –°–ë–û–†–ö–ê [{profile.upper()}] ---\n", "info")
        Config.BIN_DIR.mkdir(exist_ok=True); Config.OBJ_DIR.mkdir(exist_ok=True)
        
        sources = []
        for d in [Config.ENGINE_DIR, Config.GAME_DIR]:
            if d.exists(): sources.extend(list(d.rglob("*.c")))

        object_files, has_error = [], False
        profile_flags = ["-g", "-O0"] if profile == "Debug" else ["-O3", "-s"]
        common_flags = [f"-I{Config.INCLUDE_DIR}", f"-I{Config.ASSETS_DIR}", "-Wall"] + profile_flags

        for src_path in sources:
            rel = src_path.relative_to(Config.ROOT_DIR)
            obj = Config.OBJ_DIR / str(rel).replace(os.sep, "_").replace(".c", ".o")
            object_files.append(str(obj))
            if obj.exists() and os.path.getmtime(obj) > os.path.getmtime(src_path): continue 

            cmd = [Config.COMPILER, "-c", str(src_path), "-o", str(obj)] + common_flags
            if "engine" in src_path.parts and src_path.name == "main.c": cmd.append("-Dmain=__engine_dummy_main")

            self.console_log(f"Compiling: {rel}\n", "dim")
            proc = subprocess.run(cmd, capture_output=True, text=True, cwd=Config.ROOT_DIR)
            if proc.stderr: self._parse_gcc_output(proc.stderr)
            if proc.returncode != 0: has_error = True; break

        if not has_error:
            self.console_log("–õ–∏–Ω–∫–æ–≤–∫–∞...\n", "info")
            out = Config.BIN_DIR / Config.OUTPUT_NAME
            link_flags = ["-lopengl32", "-lglu32", "-lgdi32", "-lwinmm"] if platform.system() == "Windows" else ["-lGL", "-lGLU", "-lm", "-lX11", "-lXrandr"]
            if profile == "Release" and platform.system() == "Windows": link_flags.append("-mwindows")
            
            l_cmd = [Config.COMPILER] + object_files + ["-o", str(out)] + common_flags + link_flags
            proc = subprocess.run(l_cmd, capture_output=True, text=True, cwd=Config.ROOT_DIR)
            if proc.stderr: self._parse_gcc_output(proc.stderr)
            if proc.returncode == 0:
                self.console_log(f"–£–°–ü–ï–®–ù–û!\n", "success")
                if run_after: self.run_game()
        
        self.is_building = False
        self.app_instance.set_ui_busy(False)

    def _parse_gcc_output(self, text):
        for line in text.splitlines():
            match = self.err_pattern.match(line)
            if match:
                f, l, c, s, m = match.groups()
                self.app_instance.add_issue(f, l, s, m)
                self.console_log(line + "\n", "error" if s == "error" else "warning")
            else: self.console_log(line + "\n")

    def run_game(self):
        exe = Config.BIN_DIR / Config.OUTPUT_NAME
        if not exe.exists(): return
        try: self.game_process = subprocess.Popen([str(exe)], cwd=Config.ROOT_DIR)
        except Exception as e: self.console_log(f"–û—à–∏–±–∫–∞: {e}\n", "error")

# --- –ì–õ–ê–í–ù–û–ï –û–ö–ù–û ---
class StudioApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(f"{Config.APP_NAME} v{Config.VERSION}")
        self.geometry("1200x850")
        ctk.set_appearance_mode(Config.THEME)
        
        self.build_system = BuildSystem(self)
        self.file_watcher = FileWatcher(lambda: self.build_system.build(self.profile_var.get(), True))
        self.updater = Updater(self.log_to_console)
        
        self.grid_columnconfigure(1, weight=1); self.grid_rowconfigure(0, weight=1)

        # –õ–ï–í–û–ï –ú–ï–ù–Æ
        self.sidebar = ctk.CTkFrame(self, width=220, corner_radius=0)
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        ctk.CTkLabel(self.sidebar, text="NEW ENGINE", font=("Arial", 22, "bold")).pack(pady=20)
        
        ctk.CTkLabel(self.sidebar, text="–ü—Ä–æ—Ñ–∏–ª—å —Å–±–æ—Ä–∫–∏:", font=("Arial", 12)).pack()
        self.profile_var = ctk.StringVar(value="Debug")
        ctk.CTkOptionMenu(self.sidebar, values=["Debug", "Release"], variable=self.profile_var).pack(padx=20, pady=10)

        self.btn_build = ctk.CTkButton(self.sidebar, text="üî® Build", command=lambda: self.build_system.build(self.profile_var.get(), False))
        self.btn_build.pack(padx=20, pady=5)
        self.btn_run = ctk.CTkButton(self.sidebar, text="‚ñ∂ Run", command=self.build_system.run_game, fg_color="green")
        self.btn_run.pack(padx=20, pady=5)
        self.btn_br = ctk.CTkButton(self.sidebar, text="üöÄ Build & Run", command=lambda: self.build_system.build(self.profile_var.get(), True))
        self.btn_br.pack(padx=20, pady=5)
        
        self.chk_autobuild = ctk.CTkSwitch(self.sidebar, text="‚ö° Auto-Build", command=self.toggle_autobuild)
        self.chk_autobuild.pack(padx=20, pady=20)

        # –í–ö–õ–ê–î–ö–ò
        self.tab_view = ctk.CTkTabview(self)
        self.tab_view.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        
        self.setup_logs_tab(self.tab_view.add("–õ–æ–≥–∏ & –û—à–∏–±–∫–∏"))
        self.setup_assets_tab(self.tab_view.add("–ê—Å—Å–µ—Ç—ã"))
        self.setup_system_tab(self.tab_view.add("–°–∏—Å—Ç–µ–º–∞"))
        self.setup_update_tab(self.tab_view.add("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ"))

    def setup_logs_tab(self, tab):
        tab.grid_columnconfigure(0, weight=1); tab.grid_rowconfigure((0, 1), weight=1)
        self.issues_tree = ttk.Treeview(tab, columns=("F", "L", "T", "M"), show='headings')
        for c, h, w in [("F", "–§–∞–π–ª", 150), ("L", "–°—Ç—Ä", 50), ("T", "–¢–∏–ø", 80), ("M", "–°–æ–æ–±—â–µ–Ω–∏–µ", 400)]:
            self.issues_tree.heading(c, text=h); self.issues_tree.column(c, width=w)
        self.issues_tree.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        self.console = LogPanel(tab); self.console.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)

    def setup_assets_tab(self, tab):
        tab.grid_columnconfigure(0, weight=1)
        ctk.CTkLabel(tab, text="OBJ to Header Converter", font=("Arial", 16, "bold")).pack(pady=10)
        self.btn_sel_obj = ctk.CTkButton(tab, text="–í—ã–±—Ä–∞—Ç—å .obj", command=self.select_obj)
        self.btn_sel_obj.pack(pady=5)
        self.lbl_obj = ctk.CTkLabel(tab, text="–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω"); self.lbl_obj.pack()
        self.btn_conv = ctk.CTkButton(tab, text="–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å", command=self.convert_obj, state="disabled")
        self.btn_conv.pack(pady=10)
        self.asset_log = ctk.CTkTextbox(tab, height=100); self.asset_log.pack(fill="x", padx=20)

    def setup_system_tab(self, tab):
        tab.grid_columnconfigure((0,1), weight=1)
        f_h = ctk.CTkFrame(tab); f_h.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        ctk.CTkLabel(f_h, text="–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞", font=("Arial", 14, "bold")).pack(pady=5)
        self.health_box = ctk.CTkTextbox(f_h, height=150); self.health_box.pack(padx=5, pady=5)
        ctk.CTkButton(f_h, text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å", command=self.run_diag).pack(pady=5)
        
        f_t = ctk.CTkFrame(tab); f_t.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        ctk.CTkLabel(f_t, text="–®–∞–±–ª–æ–Ω—ã", font=("Arial", 14, "bold")).pack(pady=5)
        for n in TemplateManager.TEMPLATES:
            ctk.CTkButton(f_t, text=f"–ü—Ä–∏–º–µ–Ω–∏—Ç—å {n}", command=lambda n=n: self.apply_tmpl(n)).pack(pady=5)

    def setup_update_tab(self, tab):
        ctk.CTkButton(tab, text="–û–±–Ω–æ–≤–∏—Ç—å –°—Ç—É–¥–∏—é", command=lambda: threading.Thread(target=self.updater.update_studio, daemon=True).start()).pack(pady=10)
        ctk.CTkButton(tab, text="–û–±–Ω–æ–≤–∏—Ç—å –î–≤–∏–∂–æ–∫", command=lambda: threading.Thread(target=self.updater.update_engine, daemon=True).start(), fg_color="orange").pack(pady=10)

    # –•–µ–ª–ø–µ—Ä—ã
    def toggle_autobuild(self):
        if self.chk_autobuild.get(): self.file_watcher.start(); self.log_to_console("Auto-Build ON\n", "success")
        else: self.file_watcher.watching = False
    def select_obj(self):
        p = ctk.filedialog.askopenfilename(filetypes=[("OBJ", "*.obj")])
        if p: self.obj_p = Path(p); self.lbl_obj.configure(text=self.obj_p.name); self.btn_conv.configure(state="normal")
    def convert_obj(self):
        Config.ASSETS_DIR.mkdir(exist_ok=True)
        code = AssetConverter.convert_obj_to_h(self.obj_p)
        (Config.ASSETS_DIR / (self.obj_p.stem + ".h")).write_text(code)
        self.asset_log.insert("end", f"Success: {self.obj_p.stem}.h created\n")
    def run_diag(self):
        self.health_box.delete("1.0", "end")
        ok, m = SystemHealth.check_gcc(); self.health_box.insert("end", f"GCC: {'‚úÖ' if ok else '‚ùå'} {m}\n")
        for f, ex in SystemHealth.check_folders(): self.health_box.insert("end", f"{'‚úÖ' if ex else '‚ùå'} {f}\n")
    def apply_tmpl(self, n):
        if messagebox.askyesno("?", f"Apply {n}?"): TemplateManager.apply_template(n)
    def add_issue(self, f, l, s, m): self.after(0, lambda: self.issues_tree.insert("", "end", values=(f, l, s, m)))
    def clear_issues(self): self.after(0, lambda: [self.issues_tree.delete(i) for i in self.issues_tree.get_children()])
    def log_to_console(self, t, g=None): self.after(0, lambda: self.console.write(t, g))
    def clear_console(self): self.after(0, lambda: self.console.clear())
    def set_ui_busy(self, b):
        s = "disabled" if b else "normal"
        self.btn_build.configure(state=s); self.btn_run.configure(state=s); self.btn_br.configure(state=s)

class LogPanel(ctk.CTkTextbox):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.configure(state="disabled", font=("Consolas", 11))
        self.tag_config("error", foreground="#ff5555"); self.tag_config("warning", foreground="#ffb86c")
        self.tag_config("success", foreground="#50fa7b"); self.tag_config("info", foreground="#8be9fd"); self.tag_config("dim", foreground="#6272a4")
    def write(self, t, g=None):
        self.configure(state="normal"); self.insert("end", t, g); self.see("end"); self.configure(state="disabled")
    def clear(self):
        self.configure(state="normal"); self.delete("1.0", "end"); self.configure(state="disabled")

if __name__ == "__main__":
    app = StudioApp(); app.mainloop()